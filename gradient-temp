#!/usr/bin/env bash
#
#  gradient-temp
#
#  A temperature indicator for i3blocks and polybar, colored according to heat
#
#  Requires:
#    awk (POSIX compatible)
#    lm_sensors
#
#  Optional:
#    fonts-font-awesome
#
#  Copyright (c) 2018 Beau Hastings. All rights reserved
#  License: GNU General Public License v2
#
#  Author: Beau Hastings <beau@saweet.net>
#  URL: https://github.com/hastinbe/i3blocks-gradient-temp

FONT=${FONT:-"FontAwesome"}
SENSOR=${SENSOR:-$BLOCK_INSTANCE}
GRADIENT=${GRADIENT:-true}
FAHRENHEIT=${FAHRENHEIT:-false}
COLOR_TEMP=${COLOR_TEMP:-"white"}
COLOR_GRADIENT_START=${COLOR_GRADIENT_START:-"#0000FF"}
COLOR_GRADIENT_END=${COLOR_GRADIENT_END:-"#FF0000"}
SYMBOL_C=${SYMBOL_C:-"&#x2103;"}
SYMBOL_F=${SYMBOL_F:-"&#x2109;"}
TEMP_SUBFEATURE=${TEMP_SUBFEATURE:-"temp1"}
BAR_TYPE=${BAR_TYPE:-"i3blocks"}

define_helpers() {
    empty() {
        [[ -z $1 ]]
    }

    not_empty() {
        [[ -n $1 ]]
    }

    isset() {
        [[ -v $1 ]]
    }

    error() {
        echo "$COLOR_RED$*$COLOR_RESET"
    }

    has_color() {
        [ "$(tput colors)" -ge 8 ] &>/dev/null && [ -t 1 ]
    }

    # Returns the minimum of two numbers
    min() {
        if (($1 < $2)); then
            echo "$1"
        else
            echo "$2"
        fi
    }

    # Returns the maximum of two numbers
    max() {
        if (($1 > $2)); then
            echo "$1"
        else
            echo "$2"
        fi
    }

    # Clamps a value between a minimum and maximum
    clamp() {
        min "$(max "$1" "$2")" "$3"
    }

    deg_ctof() {
        echo "$((($1 * 9) / 5 + 32))"
    }

    # Validate hex color format (#RRGGBB)
    is_valid_hex_color() {
        [[ $1 =~ ^#[0-9A-Fa-f]{6}$ ]]
    }

    # Validate that a number is a valid temperature
    is_valid_temp() {
        [[ $1 =~ ^-?[0-9]+\.?[0-9]*$ ]]
    }

    # Check if command exists
    command_exists() {
        command -v "$1" >/dev/null 2>&1
    }

    # Convert HTML entity to Unicode character
    # Arguments:
    #   $1 - HTML entity (e.g., &#x2103; or &#8451;)
    html_entity_to_unicode() {
        local entity="$1"
        local code

        # Handle hex entities like &#x2103;
        if [[ $entity =~ ^\&\#x([0-9A-Fa-f]+)\;$ ]]; then
            code="${BASH_REMATCH[1]}"
            # Convert hex to decimal
            code=$((16#$code))
        # Handle decimal entities like &#8451;
        elif [[ $entity =~ ^\&\#([0-9]+)\;$ ]]; then
            code="${BASH_REMATCH[1]}"
        else
            # Not an HTML entity, return as-is
            echo "$entity"
            return
        fi

        # Convert Unicode code point to UTF-8 bytes and output
        if [ "$code" -le 127 ]; then
            # ASCII: single byte
            printf "\\$(printf '%03o' "$code")"
        elif [ "$code" -le 2047 ]; then
            # 2-byte UTF-8
            local byte1=$((0xC0 | (code >> 6)))
            local byte2=$((0x80 | (code & 0x3F)))
            printf "\\$(printf '%03o' "$byte1")\\$(printf '%03o' "$byte2")"
        elif [ "$code" -le 65535 ]; then
            # 3-byte UTF-8
            local byte1=$((0xE0 | (code >> 12)))
            local byte2=$((0x80 | ((code >> 6) & 0x3F)))
            local byte3=$((0x80 | (code & 0x3F)))
            printf "\\$(printf '%03o' "$byte1")\\$(printf '%03o' "$byte2")\\$(printf '%03o' "$byte3")"
        else
            # 4-byte UTF-8 (not needed for common symbols)
            local byte1=$((0xF0 | (code >> 18)))
            local byte2=$((0x80 | ((code >> 12) & 0x3F)))
            local byte3=$((0x80 | ((code >> 6) & 0x3F)))
            local byte4=$((0x80 | (code & 0x3F)))
            printf "\\$(printf '%03o' "$byte1")\\$(printf '%03o' "$byte2")\\$(printf '%03o' "$byte3")\\$(printf '%03o' "$byte4")"
        fi
    }
}

temp() {
    local temp
    temp=$(subfeature_f "${TEMP_SUBFEATURE}_input")

    if empty "$temp"; then
        error "Failed to read temperature from sensor (${TEMP_SUBFEATURE}_input)"
        return 1
    fi

    if $FAHRENHEIT; then temp=$(deg_ctof "$temp"); fi

    echo "$temp"
}

temp_max() {
    local temp
    temp=$(subfeature_f "${TEMP_SUBFEATURE}_max")

    if $FAHRENHEIT; then temp=$(deg_ctof "$temp"); fi

    echo "$temp"
}

temp_crit() {
    local temp
    temp=$(subfeature_f "${TEMP_SUBFEATURE}_crit")

    if $FAHRENHEIT; then temp=$(deg_ctof "$temp"); fi

    echo "$temp"
}

subfeature_f() {
    awk -W posix "/$1/ {printf \"%.1f\", \$2; exit}" <<< "$SENSORS"
}

temp_symbol() {
    local symbol
    if $FAHRENHEIT; then
        symbol="$SYMBOL_F"
    else
        symbol="$SYMBOL_C"
    fi

    # Convert HTML entities to Unicode for polybar
    if [ "$BAR_TYPE" = "polybar" ]; then
        html_entity_to_unicode "$symbol"
    else
        echo "$symbol"
    fi
}

# Interpolate between 2 RGB colors
#
# Arguments:
#   $1 - Color to interpolate from, as a hex triplet prefixed with #
#   $2 - Color to interpolate to, as a hex triplet prefixed with #
#   $3 - Amount of steps needed to get from start to end color
interpolate_rgb() {
    local steps=$3 colors=() color1=$1 color2=$2

    if ! is_valid_hex_color "$color1"; then
        error "Invalid start color format: $color1 (expected #RRGGBB)"
        return 1
    fi

    if ! is_valid_hex_color "$color2"; then
        error "Invalid end color format: $color2 (expected #RRGGBB)"
        return 1
    fi

    local startR=$(( 16#${color1:1:2} ))
    local startG=$(( 16#${color1:3:2} ))
    local startB=$(( 16#${color1:5:2} ))
    local endR=$(( 16#${color2:1:2} ))
    local endG=$(( 16#${color2:3:2} ))
    local endB=$(( 16#${color2:5:2} ))

    local stepR=$(( (endR - startR) / steps ))
    local stepG=$(( (endG - startG) / steps ))
    local stepB=$(( (endB - startB) / steps ))

    for i in $(seq 0 "$steps"); do
        local -i R=$(( startR + (stepR * i) ))
        local -i G=$(( startG + (stepG * i) ))
        local -i B=$(( startB + (stepB * i) ))

        colors+=( "$(printf "#%02x%02x%02x\n" $R $G $B)" )
    done

    echo "${colors[@]}"
}

# Get color for the given temperature
#
# Arguments:
#   $1 - The temperature
#   $2 - Maximum temperature
temp_color() {
    local colors
    local cache_key="${COLOR_GRADIENT_START}:${COLOR_GRADIENT_END}"

    # Cache gradient colors to avoid recomputation
    if [[ -z ${GRADIENT_CACHE[$cache_key]:-} ]]; then
        GRADIENT_CACHE[$cache_key]=$(interpolate_rgb "$COLOR_GRADIENT_START" "$COLOR_GRADIENT_END" 10)
    fi

    read -ra colors <<< "${GRADIENT_CACHE[$cache_key]}"

    if not_empty "$2"; then
        plookup "$1" "$2" "${colors[@]}"
    fi
}

# Retrieve an item from the provided lookup table based on the percentage of a number
#
# Arguments:
#   $1 - A number
#   $2 - Number to get a percentage of
#   $3 - An array of potential values
plookup() {
    if empty "$2" || empty "$3"; then
        return
    fi

    local table=( "${@:3}" )
    local temp
    temp=$(min "${1%.*}" "${2%.*}")

    # Calculate percentage: (temp / max_temp) * 100
    # Then map to array index: (percentage / 100) * array_length
    local percent=$(( temp * 100 / ${2%.*} ))
    local index=$(( percent * ${#table[@]} / 100 ))

    index=$(clamp $index 0 $(( ${#table[@]} - 1 )) )

    echo "${table[$index]}"
}

# Output text wrapped in a span element (i3blocks) or polybar format
#
# Options:
#   -c <color>  To specify a text color
#
# Arguments:
#   $1 or $3 - String to encapsulate within a span
span() {
    local -A attribs
    local text="$*"
    local color=""

    if [ "$1" = "-c" ]; then
        if not_empty "$2"; then
            color="$2"
        fi
        text="${*:3}"
    fi

    # Output format based on bar type
    if [ "$BAR_TYPE" = "polybar" ]; then
        # Polybar format: %{F#color}text%{F-}
        local output=""
        if not_empty "$color"; then
            output="%{F$color}"
        fi
        if not_empty "$FONT"; then
            # Polybar font tags: %{T#} where # is font index
            # For simplicity, we'll just output the text
            # Font configuration should be done in polybar config
            output="${output}$text"
        else
            output="${output}$text"
        fi
        if not_empty "$color"; then
            output="${output}%{F-}"
        fi
        echo "$output"
    else
        # i3blocks Pango format: <span attributes>text</span>
        if not_empty "$FONT"; then attribs[font]="$FONT"; fi
        if not_empty "$color"; then attribs[color]="$color"; fi
        echo "<span$(build_attribs attribs)>$text</span>"
    fi
}

# Builds html element attributes
#
# Arguments:
#   $1 - An associative array of attribute-value pairs
build_attribs() {
    local -n attrs=$1
    for key in "${!attrs[@]}"; do
        echo -n " $key='${attrs[$key]}'"
    done
    echo
}

# Colors text using either the first or second color
#
# Arguments:
#   $1 - Text
#   $2 - Color to use if toggle is false
#   $3 - Color to use if toggle is true
#   $4 - A boolean used to toggle between colors
#
# Returns:
#   The colored text
multicolor() {
    local color="$2"
    local toggle=$4

    if $toggle && not_empty "$3"; then
        color="$3"
    fi

    if not_empty "$color"; then
        span -c "$color" "$1"
    else
        span "$1"
    fi
}

define_commands() {
    # List available sensors
    list_sensors() {
        if ! command_exists sensors; then
            error "sensors command not found. Please install lm_sensors."
            exit 1
        fi

        echo "Available sensors:"
        sensors -u 2>/dev/null | awk -W posix '
            /^[^[:space:]]+:/ {
                sensor = $0
                sub(/:$/, "", sensor)
                print "  " sensor
            }
        ' || {
            error "Failed to list sensors"
            exit 1
        }
    }

    # Query a sensor.
    #
    # Arguments:
    #   Sensor        (string) Sensor to query.
    query_sensor() {
        local sensor=${1:?$(error 'Sensor is required')}
        local temp temp_max temp_crit temp_color colored_temp

        if ! command_exists sensors; then
            error "sensors command not found. Please install lm_sensors."
            exit 1
        fi

        SENSORS=$(sensors -u "$sensor" 2>/dev/null)
        if [ -z "$SENSORS" ]; then
            error "Failed to query sensor: $sensor"
            exit 1
        fi

        temp=$(temp)
        if [ $? -ne 0 ] || empty "$temp"; then
            error "Failed to read temperature"
            exit 1
        fi

        if isset OVERRIDE_MAX_TEMP; then
            if ! is_valid_temp "$OVERRIDE_MAX_TEMP"; then
                error "Invalid maximum temperature: $OVERRIDE_MAX_TEMP"
                exit 1
            fi
            temp_max="$OVERRIDE_MAX_TEMP"
        else
            temp_max=$(temp_max)
        fi

        if isset OVERRIDE_CRIT_TEMP; then
            if ! is_valid_temp "$OVERRIDE_CRIT_TEMP"; then
                error "Invalid critical temperature: $OVERRIDE_CRIT_TEMP"
                exit 1
            fi
            temp_crit="$OVERRIDE_CRIT_TEMP"
        else
            temp_crit=$(temp_crit)
        fi

        temp_color=$(temp_color "$temp" "$temp_max")
        colored_temp=$(multicolor "${temp}$(temp_symbol)" "$COLOR_TEMP" "$temp_color" $GRADIENT)

        echo -e "$colored_temp\n$colored_temp\n"

        if not_empty "$temp_crit" && temp_gt_eq "$temp" "$temp_crit"; then
            EXITCODE="$EX_URGENT"
        elif not_empty "$temp_max" && temp_gt_eq "$temp" "$temp_max"; then
            EXITCODE="$EX_URGENT"
        fi
    }
}

# Display program usage
usage() {
    cat <<-EOF 1>&2
Usage: $0 [<options>] <command> [<args>]

Display a temperature indicator using lm_sensors for i3blocks or polybar.

${COLOR_YELLOW}Commands:${COLOR_RESET}
  ${COLOR_GREEN}query <sensor>${COLOR_RESET}            query sensor
  ${COLOR_GREEN}list${COLOR_RESET}                      list available sensors
  ${COLOR_GREEN}help${COLOR_RESET}                      display help

${COLOR_YELLOW}Options:${COLOR_RESET}
  -b <type>     set bar type: i3blocks (default) or polybar
  -H            display temperatures in fahrenheit
  -G            disable color gradient
  -c <temp>     override critical temperature
  -m <temp>     override maximum temperature
  -f <font>     set font for text and symbols
  -t <color>    set color when gradient is disabled
  -S <#color>   set gradient start color (hex triplet)
  -E <#color>   set gradient end color (hex triplet)
  -C <symbol>   set celsius symbol
  -F <symbol>   set fahrenheit symbol
  -T <feature>  set temperature subfeature (default: temp1)
  -h            display this help and exit
EOF
    exit "$EX_USAGE"
}

temp_gt_eq() {
    (( ${1%.*} >= ${2%.*} ))
}

setup_color() {
    if has_color; then
        COLOR_RESET=$'\033[0m'
        COLOR_RED=$'\033[0;31m'
        COLOR_GREEN=$'\033[0;32m'
        COLOR_YELLOW=$'\033[0;33m'
        COLOR_MAGENTA=$'\033[0;35m'
        COLOR_CYAN=$'\033[0;36m'
    fi
}

# Rearrange all options to place flags first
# Author: greycat
# URL: https://mywiki.wooledge.org/ComplexOptionParsing
arrange_opts() {
    local flags args optstr=$1
    shift

    while (($#)); do
        case $1 in
            --)
                args+=("$@")
                break;
                ;;
            -*)
                flags+=("$1")
                if [[ $optstr == *"${1: -1}:"* ]]; then
                    flags+=("$2")
                    shift
                fi
                ;;
            *)
                args+=("$1")
                ;;
        esac
        shift
    done
    OPTARR=("${flags[@]}" "${args[@]}")
}

parse_opts() {
    local optstring=b:c:C:E:f:F:GhHm:S:t:T:

    arrange_opts "$optstring" "$@"
    set -- "${OPTARR[@]}"

    OPTIND=1

    while getopts "$optstring" opt; do
        case "$opt" in
            b    ) BAR_TYPE=$OPTARG ;;
            c    ) OVERRIDE_CRIT_TEMP=$OPTARG ;;
            C    ) SYMBOL_C=$OPTARG ;;
            E    ) COLOR_GRADIENT_END=$OPTARG ;;
            f    ) FONT=$OPTARG ;;
            F    ) SYMBOL_F=$OPTARG ;;
            G    ) GRADIENT=false ;;
            H    ) FAHRENHEIT=true ;;
            m    ) OVERRIDE_MAX_TEMP=$OPTARG ;;
            S    ) COLOR_GRADIENT_START=$OPTARG ;;
            t    ) COLOR_TEMP=$OPTARG ;;
            T    ) TEMP_SUBFEATURE=$OPTARG ;;
            h | *) usage ;;
        esac
    done

    read -ra CMDARGS <<< "${OPTARR[@]:$((OPTIND-1))}"
}

exec_command() {
    IFS=' ' read -ra ARGS <<< "$1"
    set -- "${ARGS[@]}"

    COMMAND=${1:?$(error 'A command is required')}
    shift

    case "$COMMAND" in
        query)
            case "$#" in
                1)
                    SENSOR="$1"
                    ;;
                *)
                    if empty "$SENSOR"; then
                        usage
                    fi
                    ;;
            esac

            query_sensor "$SENSOR"
            ;;
        list)
            list_sensors
            ;;
        output)
            case "$#" in 0) usage ;; esac
            # output_volume "$*"
            exit "${EXITCODE:-$EX_OK}"
            ;;
        # outputs)
        #     list_output_formats
        #     ;;
        *)
            usage
            ;;
    esac
}

###############################################################################

main() {
    # Getopt parsing variables
    declare OPTIND
    declare -a OPTARR CMDARGS

    ###########################################################
    # Non-command line option variables
    ###########################################################

    # Exit codes
    declare -ir \
        EX_OK=0 \
        EX_URGENT=33 \
        EX_USAGE=64

    # Main program exit code
    declare -i EXITCODE=$EX_OK

    # Gradient color cache
    declare -A GRADIENT_CACHE

    declare \
        COLOR_RESET \
        COLOR_RED \
        COLOR_GREEN \
        COLOR_YELLOW \
        COLOR_MAGENTA \
        COLOR_CYAN

    ###########################################################
    # Command line option variables
    ###########################################################

    declare \
        COMMAND

    define_helpers
    define_commands

    setup_color

    parse_opts "$@"

    exec_command "${CMDARGS[*]}"

    exit ${EXITCODE:-$EX_OK}
}

main "$@"
